package license

import (
	"encoding/base64"
	"net"
	"os"
	"os/exec"
	"runtime"
	"slices"
	"strings"
	"time"

	"github.com/tidwall/gjson"
	"github.com/xyzj/toolbox/crypto"
	"github.com/xyzj/toolbox/json"
)

const tf = `2006-01-02T15:04:05Z`

func encodeAndXOR(input string, key byte) string {
	data := []byte(input)
	for i := range data {
		data[i] ^= key
	}
	return base64.StdEncoding.EncodeToString(data)
}

func decodeAndXOR(parts []byte, key byte) string {
	result := ""
	part, _ := base64.StdEncoding.DecodeString(string(parts))
	for _, decoded := range part {
		decoded ^= key
		result += string(decoded)
	}
	return result
}

func getEcc() string {
	return decodeAndXOR([]byte{0x56, 0x46, 0x46, 0x36, 0x57, 0x6c, 0x68, 0x49, 0x58, 0x46, 0x78, 0x51, 0x55, 0x53, 0x73, 0x6f, 0x63, 0x47, 0x6c, 0x4d, 0x55, 0x69, 0x67, 0x71, 0x59, 0x79, 0x6c, 0x62, 0x61, 0x56, 0x42, 0x59, 0x53, 0x31, 0x42, 0x51, 0x53, 0x32, 0x46, 0x65, 0x66, 0x48, 0x4a, 0x31, 0x66, 0x48, 0x6f, 0x71, 0x64, 0x56, 0x4d, 0x32, 0x51, 0x46, 0x74, 0x49, 0x4b, 0x46, 0x52, 0x68, 0x58, 0x48, 0x51, 0x74, 0x59, 0x31, 0x74, 0x39, 0x56, 0x58, 0x5a, 0x59, 0x64, 0x6c, 0x35, 0x61, 0x57, 0x6d, 0x68, 0x65, 0x53, 0x6c, 0x51, 0x74, 0x49, 0x46, 0x68, 0x75, 0x58, 0x46, 0x46, 0x32, 0x54, 0x45, 0x68, 0x64, 0x53, 0x48, 0x35, 0x59, 0x58, 0x47, 0x31, 0x53, 0x4d, 0x6c, 0x56, 0x31, 0x57, 0x6c, 0x35, 0x67, 0x63, 0x33, 0x31, 0x57, 0x66, 0x31, 0x38, 0x75, 0x4b, 0x7a, 0x4a, 0x39, 0x4c, 0x56, 0x35, 0x62, 0x53, 0x31, 0x64, 0x50, 0x51, 0x48, 0x64, 0x61, 0x59, 0x57, 0x46, 0x31, 0x4c, 0x47, 0x35, 0x64, 0x54, 0x48, 0x51, 0x32, 0x61, 0x56, 0x46, 0x63, 0x65, 0x6c, 0x64, 0x34, 0x56, 0x6b, 0x68, 0x53, 0x4b, 0x45, 0x35, 0x79, 0x63, 0x45, 0x70, 0x71, 0x4b, 0x32, 0x46, 0x57, 0x65, 0x79, 0x39, 0x4a, 0x61, 0x69, 0x42, 0x34, 0x49, 0x57, 0x67, 0x76, 0x66, 0x6c, 0x42, 0x4a, 0x4b, 0x43, 0x6b, 0x67, 0x4c, 0x53, 0x70, 0x37, 0x49, 0x47, 0x42, 0x68, 0x58, 0x69, 0x78, 0x2b, 0x65, 0x6e, 0x78, 0x65, 0x4c, 0x56, 0x31, 0x39, 0x56, 0x57, 0x68, 0x75, 0x4a, 0x43, 0x51, 0x3d}, 0x19)
}

func getSM2() string {
	return decodeAndXOR([]byte{0x53, 0x30, 0x39, 0x42, 0x55, 0x6b, 0x64, 0x68, 0x51, 0x30, 0x64, 0x4c, 0x52, 0x45, 0x74, 0x42, 0x52, 0x48, 0x39, 0x33, 0x51, 0x56, 0x56, 0x4c, 0x4d, 0x6a, 0x39, 0x48, 0x59, 0x55, 0x4e, 0x42, 0x52, 0x55, 0x56, 0x33, 0x52, 0x45, 0x35, 0x4c, 0x50, 0x31, 0x42, 0x48, 0x58, 0x30, 0x39, 0x79, 0x52, 0x45, 0x35, 0x74, 0x63, 0x57, 0x4a, 0x78, 0x54, 0x30, 0x52, 0x48, 0x56, 0x31, 0x64, 0x68, 0x56, 0x6d, 0x56, 0x31, 0x59, 0x32, 0x74, 0x77, 0x54, 0x54, 0x38, 0x74, 0x64, 0x69, 0x30, 0x31, 0x5a, 0x32, 0x6c, 0x53, 0x58, 0x31, 0x4e, 0x65, 0x53, 0x57, 0x42, 0x72, 0x56, 0x7a, 0x56, 0x48, 0x61, 0x31, 0x4e, 0x70, 0x63, 0x44, 0x42, 0x41, 0x4d, 0x6b, 0x39, 0x6b, 0x53, 0x45, 0x39, 0x63, 0x4e, 0x33, 0x49, 0x33, 0x5a, 0x32, 0x4a, 0x4f, 0x4c, 0x57, 0x46, 0x46, 0x59, 0x56, 0x39, 0x50, 0x54, 0x57, 0x6c, 0x44, 0x5a, 0x58, 0x77, 0x33, 0x55, 0x30, 0x52, 0x68, 0x62, 0x7a, 0x52, 0x75, 0x56, 0x45, 0x64, 0x49, 0x52, 0x55, 0x64, 0x48, 0x55, 0x6a, 0x35, 0x65, 0x66, 0x6c, 0x5a, 0x71, 0x61, 0x6e, 0x55, 0x78, 0x63, 0x32, 0x68, 0x65, 0x59, 0x33, 0x55, 0x2b, 0x54, 0x7a, 0x4a, 0x78, 0x4e, 0x54, 0x56, 0x4c, 0x55, 0x6d, 0x64, 0x68, 0x58, 0x6c, 0x63, 0x31, 0x62, 0x6d, 0x42, 0x33, 0x53, 0x47, 0x52, 0x33, 0x53, 0x45, 0x6c, 0x6f, 0x59, 0x7a, 0x42, 0x70, 0x51, 0x54, 0x49, 0x32, 0x66, 0x30, 0x46, 0x77, 0x4d, 0x45, 0x35, 0x72, 0x63, 0x30, 0x4a, 0x6a, 0x4d, 0x56, 0x4a, 0x7a, 0x53, 0x56, 0x52, 0x75, 0x56, 0x6c, 0x39, 0x71, 0x59, 0x7a, 0x4e, 0x54, 0x64, 0x54, 0x4a, 0x63, 0x4d, 0x32, 0x31, 0x57, 0x52, 0x7a, 0x59, 0x7a, 0x61, 0x6d, 0x64, 0x76, 0x5a, 0x54, 0x4e, 0x30, 0x59, 0x47, 0x56, 0x46, 0x51, 0x48, 0x49, 0x7a, 0x52, 0x45, 0x51, 0x3d}, 0x6)
}

type licenseInfo struct {
	Fingerprint string `json:"fingerprint"`
	Deadline    string `json:"deadline"`
	Signature   string `json:"signature"`
}

func getMacAddress() string {
	interfaces, _ := net.Interfaces()
	ss := []string{}
	for _, i := range interfaces {
		if len(i.HardwareAddr) > 0 {
			ss = append(ss, i.HardwareAddr.String())
		}
	}
	if len(ss) > 0 {
		slices.Sort(ss)
		return strings.Join(ss, "|")
	}
	return ""
}

func getHostname() string {
	name, _ := os.Hostname()
	return name
}

func getMachineID() string {
	switch runtime.GOOS {
	case "windows":
		cmd := exec.Command("wmic", "path", "win32_computersystemproduct", "get", "uuid")
		out, err := cmd.CombinedOutput()
		if err == nil {
			return string(out)
		}
	case "linux":
		data, err := os.ReadFile("/etc/machine-id")
		if err == nil {
			if len(data) > 0 {
				return strings.TrimSpace(string(data))
			}
		}
	}
	// fallback: use hostname as fallback ID
	return getHostname()
}

func getCPUId() string {
	switch runtime.GOOS {
	case "windows":
		cmd := exec.Command("wmic", "cpu", "get", "processorid")
		out, err := cmd.CombinedOutput()
		if err == nil {
			return string(out)
		}
	case "linux":
		cmd := exec.Command("lscpu", "-J")
		out, err := cmd.CombinedOutput()
		if err == nil {
			ii := []string{
				"Architecture:", "CPU op-mode(s):", "Address sizes:", "Byte Order:",
				"CPU(s):", "Vendor ID:", "Model name:", "CPU family:", "Model:", "Thread(s) per core:",
				"Core(s) per socket:", "Socket(s):", "Flags:",
				"L1d cache:", "L1i cache:", "L2 cache:", "L3 cache:",
			}
			ss := []string{}
			js := gjson.ParseBytes(out)
			for _, v := range js.Get("lscpu").Array() {
				if slices.Contains(ii, v.Get("field").String()) {
					ss = append(ss, v.Get("data").String())
				}
			}
			return strings.Join(ss, "_")
		}
	}
	// fallback: use hostname
	return getHostname()
}

func getFingerprint(account string) string {
	data := account
	if data == "" {
		data = getCPUId() + "-" + getHostname() + "-" + getMacAddress() + "-" + getMachineID()
	}
	h := crypto.NewHash(crypto.HashSHA256, []byte{})
	v := h.Hash([]byte(data))
	return v.Base64StringNoTail()
}

func sign(account string, t time.Time) *licenseInfo {
	f := getFingerprint(account)
	c := crypto.NewECC()
	c.SetPrivateKey(getEcc())
	v2, _ := c.Sign([]byte(f + "|" + t.Format(tf)))
	return &licenseInfo{
		Fingerprint: f,
		Deadline:    t.Format(tf),
		Signature:   v2.Base64String(),
	}
}

func verifySign(lic, fingerprint string) bool {
	c := crypto.NewSM2()
	c.SetPrivateKey(getSM2())
	ss, err := c.DecodeBase64(lic)
	if err != nil {
		return false
	}
	// ss := toolbox.DecodeString(s)
	l := &licenseInfo{}
	err = json.UnmarshalFromString(ss, l)
	if err != nil {
		return false
	}
	if fingerprint != l.Fingerprint {
		return false
	}
	t, err := time.Parse(tf, l.Deadline)
	if err != nil {
		return false
	}
	if t.Before(time.Now()) {
		return false
	}
	c2 := crypto.NewECC()
	c2.SetPrivateKey(getEcc())
	b, _ := c2.VerifySignFromBase64(l.Signature, []byte(l.Fingerprint+"|"+l.Deadline))
	return b
}

func SignMachine(t time.Time) string {
	l := sign("", t)
	b, _ := json.Marshal(l)
	// return toolbox.CodeString(string(b))
	c := crypto.NewSM2()
	c.SetPrivateKey(getSM2())
	v, _ := c.Encode(b)
	return v.Base64StringNoTail()
}

func VerifyMachine(lic string) bool {
	return verifySign(lic, getFingerprint(""))
}

func SignAccount(account string, t time.Time) string {
	if account == "" {
		return ""
	}
	l := sign(account, t)
	b, _ := json.Marshal(l)
	// return toolbox.CodeString(string(b))
	c := crypto.NewSM2()
	c.SetPrivateKey(getSM2())
	v, _ := c.Encode(b)
	return v.Base64StringNoTail()
}

func VerifyAccount(account, lic string) bool {
	return verifySign(lic, getFingerprint(account))
}
